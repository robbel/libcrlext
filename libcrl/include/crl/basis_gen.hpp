/*
    Copyright 2015 Philipp Robbel

    License: http://www.gnu.org/licenses/lgpl LGPL version 3.0, or (at your option) any later version.

    The software is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.
 */

#ifndef BASIS_GEN_HPP_
#define BASIS_GEN_HPP_

#include "crl/alp.hpp"

//
// Iterative basis construction
//

namespace crl {

// forward declarations
template<class T> class _ConjunctiveFeature;
template<class T> std::ostream& operator<<(std::ostream& os, const _ConjunctiveFeature<T>& f);

/**
 * \brief A conjunctive feature is generated by combining base features (i.e., basis functions)
 */
template<class T>
class _ConjunctiveFeature : public _FDiscreteFunction<T> {
  // operator overloads
  //friend std::ostream& operator<< <>(std::ostream& os, const _ConjunctiveFeature<T>& f);
private:
  /// \brief The (sorted) index set of basis functions that make up this conjunctive feature
  SizeVec _base_fns;
  /// \brief Hash of _base_fns for checking uniqueness
  std::size_t _hash;
public:
  /// \brief Return the (sorted) index set of basis functions that make up this conjunctive feature
  const SizeVec getBaseFeatures() const {
      return _base_fns;
  }
  /// \brief Return unique hash of this conjunctive feature
  std::size_t getHash() const {
    return _hash;
  }

  /// \brief operators
  bool operator==(const _ConjunctiveFeature<T>& other) const {
    return _hash == other._hash;
  }
  bool operator!=(const _ConjunctiveFeature<T>& other) const {
    return !(*this == other);
  }
  bool operator<(const _ConjunctiveFeature<T>& other) const {
    return _hash < other._hash;
  }
};
template<class T>
using ConjunctiveFeature = boost::shared_ptr<_ConjunctiveFeature<T>>;

/// \brief Stream output of a \a ConjunctiveFeature
template<class T>
std::ostream& operator<<(std::ostream &os, const _ConjunctiveFeature<T>& f) {
  os << "Conj({";
  for(auto h : f.getBaseFeatures()) {
      os << h << ", ";
  }
  os << "})";
  return os;
}

// // Umm, need to know corresponding function's index (the basis Id!)
// ConjunctiveFeature<T> algorithm::union(DiscreteFunction<T>, ConjunctiveFeature<T>)
// ConjunctiveFeature<T> algorithm::union(ConjunctiveFeature<T>, DiscreteFunction<T>)
// ConjunctiveFeature<T> algorithm::union(ConjunctiveFeature<T>, ConjunctiveFeature<T>)
// ConjunctiveFeature<T> algorithm::union(DiscreteFunction<T>, DiscreteFunction<T>)
// // make all of them friends to class above (or a shared impl function)
//

// iterator will check for collisions internally and only return valid ones? (param)

/**
 * \todo
 */
class BasisScore {
protected:
  /// \brief The (global) domain
  Domain _domain;
  /// \brief The (solved) factored value function
  FactoredValueFunction _value_fn;
public:
  BasisScore(const Domain& domain)
  : _domain(domain) { }

  /// \brief The (solved) factored value function that will be used for scoring
  void setFactoredValueFunction(FactoredValueFunction vfn) {
    _value_fn = std::move(vfn);
  }

  /// \brief The (abstract) scoring function for the given basis function
  virtual double score(const _DiscreteFunction<Reward>* basis) const = 0;
};

/**
 * \todo
 */
class EpsilonScore : public BasisScore {
  /// \todo
  virtual double score(const _DiscreteFunction<Reward>* basis) const {
    return 0.;
  }
};

/**
 * \todo
 */
class BEBFScore : public BasisScore {
  /// \todo
  virtual double score(const _DiscreteFunction<Reward>* basis) const {
    return 0.;
  }
};

//
// TODO: logical and basis iterator given current set
//


/**
 * \brief A BasisGenerator uses a scoring mechanism to compute the next best basis
 * \tparam Op The type of the operator to compute new candidate basis functions
 * \tparam Sc The type of the scoring method
 */
template<class Op, class Sc>
class BasisGenerator {
protected:
  /// \brief The (global) domain
  Domain _domain;
  /// \brief The (solved) factored value function
  FactoredValueFunction _value_fn;
  /// \brief Unique name of this basis generator
  std::string _name;
  /// \brief The \a BasisScore to score each candidate basis
  BasisScore _score;
public:
  BasisGenerator(const Domain& domain, std::string name = "")
  : _domain(domain), _name(name) {

  }

  /// \brief Return the next best basis function
  DiscreteFunction<Reward> nextBest() const;
};

//
// Algorithms for basis function evaluation
//

namespace algorithm {

/// \brief Score a basis function under different criteria
void scoreBasis(const Domain& domain, const _DiscreteFunction<Reward>* basis, const FactoredValueFunction& fval);

/// \brief Perform a given operation (e.g., max, min, sum) on the \a FactoredFunction for all values where the basis is `active'
/// \note Assumes that the FactoredFunction is defined over the same domain as `basis'
template<class T, class BinOp>
T evalOpOverBasis(const _DiscreteFunction<T>* basis, const FactoredFunction<T>& facfn, bool known_flat, T init, BinOp binOp) {
  assert(basis->getActionFactors().empty());
  // optimization path for basis functions with tabular storage
  const _FDiscreteFunction<T>* of = is_flat(basis, known_flat);
  const std::vector<T>* pvals = nullptr;
  typename std::vector<T>::size_type j = 0;
  if(of) {
      pvals = &of->values();
  }

  // obtain value of facfn empty functionals
  T val = T(0);
  for(const auto& empty_fn : std::get<1>(facfn)) {
      val += empty_fn->eval(State(),Action());
  }

  // manually loop over basis function domain and apply binOp
  // Note: for variable elimination cases (min, max), I could continue to run that instead!
  T manVal = init;
  const _Indicator<T>* pI = dynamic_cast<const _Indicator<T>*>(basis);
  if(pI) {
      // basis is active in exactly one state
      const State s(basis->getSubdomain(), pI->getStateIndex());
      manVal = T(0);
      for(const auto& f : std::get<0>(facfn)) {
          manVal += f->eval(s,Action());
      }
  }
  else {
      _StateIncrementIterator sitr(basis->getSubdomain());
      while(sitr.hasNext()) {
          const State& s = sitr.next();
          T basisVal = of ? (*pvals)[j++] : (*basis)(s,Action());
          if(basisVal != T(0)) { // basis is active in `s'
              T v = T(0); // candidate value
              for(const auto& f : std::get<0>(facfn)) {
                  v += f->eval(s,Action());
              }
              binOp(manVal, v);
          }
      }
  }
  val += manVal;
  return val;
}

} // namespace algorithm

} // namespace crl

#endif /*BASIS_GEN_HPP_*/
